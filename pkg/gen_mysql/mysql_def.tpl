// Code generated by {{.ToolName}} {{.Version}}. DO NOT EDIT.{{$tbl := .}}
package {{PascalToSnake $tbl.Name}}_def

$Import-Packages$

////////////////////////////////////////////////////////////////////////////////
// public interface {{ $key := $tbl.PrimaryKey }} {{ $ksize := len $key }}

{{if $tbl.PrimaryKey }}
  {{- if eq $ksize 1 }} {{$col := index $tbl.PrimaryKey 0}}
type Key = {{$col.GoType}}
  {{- else -}}
type Key struct { {{ range $i,$col := $key }}
	{{Doc $col.Doc}} {{Title $col.Name}} {{$col.GoType}} {{ end -}}
}
  {{- end }}
{{- end }}

var ({{range $i,$col := $tbl.AllColumns false}} {{if $col.Unmarshal }}
	{{Title $col.Name}}Unamrshal = {{$tbl.SvcDB}}.RawTo{{$col.Unmarshal}} {{ end }} {{end}}
{{range $i,$col := $tbl.AllColumns false }} {{if $col.Marshal }}
	{{Title $col.Name}}Marshal = {{$tbl.SvcDB}}.AnyFrom{{$col.Marshal}} {{ end }} {{end}}
)


{{if $tbl.PrimaryKey }}
func ToPrimaryKeys(rows []*{{Title $tbl.Struct}}) (ids []Key) {
	ids = make([]Key, 0, len(rows))
	for _, v := range rows { {{- if eq $ksize 1 }} {{ $id := index $key 0 }}
		ids = append(ids, v.{{Title $id.Name }}) {{else}}
		ids = append(ids, Key { {{ range $i,$col := $key }}
			{{Title $col.Name}}:v.{{Title $col.Name}} ,{{ end }}
		}) {{ end }}
	}
	return
}
{{ if $tbl.GenEx }}
func ExToPrimaryKeysEx(rows []*{{Title $tbl.Struct}}Ex) (ids []Key) {
	ids = make([]Key, 0, len(rows))
	for _, v := range rows { {{- if eq $ksize 1 }} {{ $id := index $key 0 }}
		ids = append(ids, v.{{Title $id.Name }}) {{else}}
		ids = append(ids, Key { {{ range $i,$col := $key }}
			{{Title $col.Name}}:v.{{Title $col.Name}}, {{ end }}
		}) {{ end }}
	}
	return
}{{end}}
{{end}}

////////////////////////////////////////////////////////////////////////////////
// sql statement

const (
	SQL_Insert        = "insert {{$tbl.SqlTable}}({{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{$col.SqlName}}{{end}}) values({{$tbl.Placeholder true}})"{{ if $tbl.AutoIncr}}
	SQL_Insert2       = "insert {{$tbl.SqlTable}}({{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}}) values({{$tbl.Placeholder false}})"{{end}}
	SQL_InsertValues  = ",({{$tbl.Placeholder true}})"
	SQL_InsertValues2 = ",({{$tbl.Placeholder false}})" {{if $tbl.PrimaryKey}}
	SQL_Where1        = " where ({{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}})"
	SQL_Where2        = " or ({{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}})"
	SQL_Upsert        = "insert {{$tbl.SqlTable}}({{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}}) values({{$tbl.Placeholder false}})"
	SQL_UpsertUpdate  = " on duplicate key update {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{$col.SqlName}}=values({{$col.SqlName}}){{end}}"
	SQL_Update        = "update {{$tbl.SqlTable}} set {{range $i,$col := $tbl.Columns}}{{Comma $i}}{{$col.SqlName}}=?{{end}} where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}" {{end}}
	SQL_Delete        = "delete from {{$tbl.SqlTable}}"
	SQL_Find          = "select {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}} from {{$tbl.SqlTable}}"{{ if $tbl.GenEx }}
	SQL_FindRow       = "select {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{$col.SqlName}}{{end}},{{BackQuote "modify_stamp"}},{{BackQuote "create_stamp"}} from {{$tbl.SqlTable}}"{{end}}
	SQL_Count         = "select count(*) from {{$tbl.SqlTable}}"
	SQL_Create        = "create table {{$tbl.SqlTable}} ("+ {{range $i,$col :=  $tbl.AllColumns false}}
		"{{Comma $i}}{{$col.SqlName}} {{$col.SqlType}}" + {{end}} {{ if $tbl.GenEx }}
		",{{BackQuote "modify_stamp"}} timestamp default current_timestamp on update current_timestamp" +
		",{{BackQuote "create_stamp"}} timestamp default current_timestamp" + {{end}} {{if $tbl.PrimaryKey }}
		",PRIMARY KEY ( {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.SqlName}}{{end}})" + {{end}}{{- range $i,$idx := $tbl.Index }}
		",{{if $idx.IsUnique}}UNIQUE KEY{{else}}KEY{{end}} {{BackQuote $idx.IdxName}}({{range $i,$col := $idx.Columns}}{{Comma $i}}{{$col.SqlName}}{{end}}))"+{{end}}
		") ENGINE={{$tbl.Engine}} DEFAULT CHARSET={{$tbl.Charset}} COLLATE={{$tbl.Collate}};"

	{{if $tbl.PrimaryKey}}{{if $tbl.GenUpsert }}
	STMT_Upsert = SQL_Upsert + SQL_UpsertUpdate{{end}}
	STMT_Delete = SQL_Delete + " where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}"
	STMT_Find = SQL_Find + " where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}"{{ if $tbl.GenEx }}
	STMT_FindRow = SQL_FindRow + " where {{range $i,$col := $tbl.PrimaryKey}}{{And $i}}{{$col.SqlName}}=?{{end}}"{{end}}{{end}}
{{- range $i,$idx := $tbl.Index }}{{if not $idx.IsUnique}}
	STMT_{{Title $idx.Name}}FindFrist = SQL_Find + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}} limit 1"
	STMT_{{Title $idx.Name}}FindMore =SQL_Find + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}} limit ?,?"{{ if $tbl.GenEx }}
	STMT_{{Title $idx.Name}}FindRowFirst = SQL_FindRow + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}} limit 1"{{end}}
	STMT_{{Title $idx.Name}}Count = SQL_Count + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}}"
	{{- else}}
	STMT_{{Title $idx.Name}}Find = SQL_Find + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}}"
	{{end}}{{ if $tbl.GenEx }}
	STMT_{{Title $idx.Name}}FindRowMore = SQL_FindRow + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}} limit ?,?"{{end}}
	STMT_{{Title $idx.Name}}Delete = SQL_Delete + " where {{range $i,$col := $idx.Columns}}{{And $i}}{{$col.SqlName}}=?{{end}}"
	{{end}}
)

var (
	SQL_TableColumns = map[string]string{ {{- range $i,$col :=  $tbl.AllColumns false}}
		"{{$col.Name}}": "alter table {{$tbl.SqlTable}} add {{$col.SqlName}} {{$col.SqlType}};",{{end}}
	}{{if $tbl.Index }}
	SQL_TableIndex = map[string]string{ {{- range $i,$idx := $tbl.Index }}
		"{{$idx.IdxName}}": "create {{$idx.Unique}}index {{$idx.IdxName}} on {{$tbl.SqlTable}}({{range $i,$col := $idx.Columns}}{{Comma $i}}{{$col.SqlName}}{{end}})", {{end}}
	}{{end}}
)


func NamedSQL(bufSize int)  *SQLWriter{
	sql := &SQLWriter{}
	sql.buf.Grow(bufSize)
	return sql
}


////////////////////////////////////////////////////////////////////////////////
// scan interface {{$all := $tbl.AllColumns false}}

func Scan(rows *sql.Rows) (data *{{Title $tbl.Struct}}, err error) {
	var values [{{len $all}}]sql.RawBytes
	err = rows.Scan({{range $i,$col := $tbl.AllColumns false}} &values[{{$i}}],{{end}})
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan failed, %w", err)
	}

	data = &{{Title $tbl.Struct}}{} {{range $i,$col := $tbl.AllColumns false}}
	data.{{Title $col.Name}}, err = {{Title $col.Name}}Unamrshal(values[{{$i}}])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan {{$col.Name}} failed, %w", err)
	}{{end}}
	return data, nil
}
{{ if $tbl.GenEx }}
func ScanEx(rows *sql.Rows) (data *{{Title $tbl.Struct}}Ex, err error) {
	var values [{{len $all}}+2]sql.RawBytes
	err = rows.Scan({{range $i,$col := $tbl.AllColumns false}}&values[{{$i}}],{{end}}&values[{{len $all}}],&values[{{len $all}}+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex failed, %w", err)
	}

	data = &{{Title $tbl.Struct}}Ex{} {{range $i,$col := $tbl.AllColumns false}}
	data.{{Title $col.Name}}, err = {{Title $col.Name}}Unamrshal(values[{{$i}}])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex {{$col.Name}} failed, %w", err)
	}{{end}}
	data.ModifyStamp,err = svc_db.RawToStampInt64(values[{{len $all}}])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex modify_stamp failed, %w", err)
	}
	data.CreateStamp,err = svc_db.RawToStampInt64(values[{{len $all}}+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal {{$tbl.DB}}.{{$tbl.SqlTable}} scan_ex create_stamp failed, %w", err)
	}
	return data, nil
}
{{end}}

////////////////////////////////////////////////////////////////////////////////
// exec sql stmt
type ExecStmt struct {
	buf           util.Builder
}
{{range $i,$col := $tbl.AllColumns false}}
func (w *ExecStmt) {{Title $col.Name}}() *{{$tbl.SvcDB}}.{{$col.CondV2 ""}} {
	return {{$tbl.SvcDB}}.New{{$col.CondV2 ""}} (w, &w.buf, "{{$col.Name}}")
}
{{end}}

func (w *ExecStmt) And() *ExecStmt {
	w.buf.Write([]byte(" and "))
	return w
}

func (w *ExecStmt) Or() *ExecStmt {
	w.buf.Write([]byte(" or "))
	return w
}

func (w *ExecStmt) Group(gf func(w *ExecStmt)) *ExecStmt {
	w.buf.WriteByte('(')
	gf(w)
	w.buf.WriteByte(')')
	return w
}

func (w *ExecStmt) Custom(f func(buf *util.Builder)) *ExecStmt {
	f(&w.buf)
	return w
}

func (w *ExecStmt) LimitAndOffset() *ExecStmt {
	w.buf.Write([]byte(" limit ?,?"))
	return w
}

func (w *ExecStmt) Limit() *ExecStmt {
	w.buf.Write([]byte(" limit ?"))
	return w
}

func (w *ExecStmt) Offset() *ExecStmt {
	w.buf.Write([]byte(" offset ?"))
	return w
}

func (w *ExecStmt) Oderby() *ExecOrder {
	return &ExecOrder{w}
}

func (w *ExecStmt) String() string{
	return w.buf.String()
}

func SelectWhere(bufSize int) *ExecStmt {
	w := &ExecStmt{}
	w.buf.Grow(bufSize+len(SQL_Find))
	w.buf.WriteString(SQL_Find)
	w.buf.Write([]byte(" where "))
	return w
}

func CountWhere(bufSize int) *ExecStmt {
	w := &ExecStmt{}
	w.buf.Grow(bufSize+len(SQL_Count))
	w.buf.WriteString(SQL_Count)
	w.buf.Write([]byte(" where "))
	return w
}

func DeleteWhere(bufSize int) *ExecStmt {
	w := &ExecStmt{}
	w.buf.Grow(bufSize+len(SQL_Delete))
	w.buf.WriteString(SQL_Delete)
	w.buf.Write([]byte(" where "))
	return w
}
{{ if $tbl.GenEx }}
func SelectWhereEx(bufSize int) *ExecStmt {
	w := &ExecStmt{}
	w.buf.Grow(bufSize+len(SQL_FindRow))
	w.buf.WriteString(SQL_FindRow)
	w.buf.Write([]byte(" where "))
	return w
}
{{end}}
////////////////////////////////////////////////////////////////////////////////
// order by
type ExecOrder struct {
	w *ExecStmt
}

{{range $i,$col := $tbl.AllColumns false}}
func (o *ExecOrder) {{Title $col.Name}}() *{{$tbl.SvcDB}}.ExecOrder[ExecStmt] {
	return {{$tbl.SvcDB}}.NewExecOrder[ExecStmt](o.w, &o.w.buf, "{{$col.Name}}")
}
{{end}}

////////////////////////////////////////////////////////////////////////////////
// named sql

type SQLWriter struct {
	buf util.Builder
}

func (x *SQLWriter) Select() *NamedSelect {
	x.buf.Write([]byte("select "))
	var v int
	return &NamedSelect{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *SQLWriter) Update() *NamedUpdate {
	x.buf.Write([]byte("update {{$tbl.SqlTable}} set "))
	var v int
	return &NamedUpdate{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *SQLWriter) Insert() *NamedInsert {
	return &NamedInsert{
		buf: &x.buf,
	}
}

func (x *SQLWriter) Delete() *NamedWhere {
	x.buf.Write([]byte("delete from {{$tbl.SqlTable}} where "))
	return &NamedWhere{
		buf: &x.buf,
	}
}

type NamedInsert struct {
	buf  *util.Builder
	list,values []string
}
{{range $i,$col := $tbl.AllColumns false}}
func (x *NamedInsert) {{Title $col.Name}}() *NamedInsert {
	x.list = append(x.list, "{{$col.SqlName}}")
	x.values = append(x.values, ":{{$col.Name}}")
	return x
}
{{end}}
{{ if $tbl.GenEx }}
func (x *NamedInsert) ModifyStamp() *NamedInsert {
	x.list = append(x.list, "{{BackQuote "modify_stamp"}}")
	x.values = append(x.values, ":modify_stamp")
	return x
}

func (x *NamedInsert) CreateStamp() *NamedInsert {
	x.list = append(x.list, "{{BackQuote "create_stamp"}}")
	x.values = append(x.values, ":create_stamp")
	return x
}
{{end}}

func (x *NamedInsert) ToSQL() string {
	x.buf.Write([]byte("insert {{$tbl.SqlTable}}("))
	x.buf.WriteString(strings.Join(x.list, ","))
	x.buf.Write([]byte(") values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

func (x *NamedInsert) ValuesToSQL() string {
	x.buf.Write([]byte(",values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

type NamedUpdate struct {
	buf *util.Builder
	n   *int
	values *bool
}

{{range $i,$col := $tbl.AllColumns false}}
func (x *NamedUpdate) {{Title $col.Name}}() *NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("{{$col.SqlName}}=values({{$col.SqlName}})"))
	} else {
		x.buf.Write([]byte("{{$col.SqlName}}=:{{$col.Name}}"))
	}
	*x.n++
	return x
}
{{end}}
{{ if $tbl.GenEx }}
func (x *NamedUpdate) ModifyStamp() *NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("{{BackQuote "modify_stamp"}}=values({{BackQuote "modify_stamp"}})"))
	}else {
		x.buf.Write([]byte("{{BackQuote "modify_stamp"}}=:modify_stamp"))
	}
	*x.n++
	return x
}

func (x *NamedUpdate) CreateStamp() *NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("{{BackQuote "create_stamp"}}=values({{BackQuote "create_stamp"}})"))
	}else {
		x.buf.Write([]byte("{{BackQuote "create_stamp"}}=:create_stamp"))
	}
	*x.n++
	return x
}
{{end}}

func (x *NamedUpdate) Where() *NamedWhere {
	if x.values != nil {
		panic("invalid where")
	}
	x.buf.Write([]byte(" where "))
	return &NamedWhere{
		buf: x.buf,
	}
}

func (x *NamedUpdate) ToSQL() string {
	return x.buf.String()
}

type NamedSelect struct {
	buf *util.Builder
	n   *int
}
{{range $i,$col := $tbl.AllColumns false}}
func (x *NamedSelect) {{Title $col.Name}}() *NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{$col.SqlName}}"))
	*x.n++
	return x
}
{{end}}

{{ if $tbl.GenEx }}
func (x *NamedSelect) ModifyStamp() *NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "modify_stamp"}}"))
	*x.n++
	return x
}

func (x *NamedSelect) CreateStamp() *NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "create_stamp"}}"))
	*x.n++
	return x
}{{end}}

func (x *NamedSelect) Where() *NamedWhere {
	x.buf.Write([]byte(" from {{$tbl.SqlTable}} where "))
	return &NamedWhere{
		buf: x.buf,
	}
}


func (x *NamedSelect) ToSQL() string {
	x.buf.Write([]byte(" from {{$tbl.SqlTable}}"))
	return x.buf.String()
}

type NamedWhere struct {
	buf *util.Builder
}
{{range $i,$col := $tbl.AllColumns false}}
func (x *NamedWhere) {{Title $col.Name}}() *NamedWhere {
	x.buf.Write([]byte("{{$col.SqlName}} = :{{$col.Name}}"))
	return x
}
{{end}}

{{ if $tbl.GenEx }}
func (x *NamedWhere) ModifyStamp() *NamedWhere {
	x.buf.Write([]byte("{{BackQuote "modify_stamp"}} = :modify_stamp"))
	return x
}

func (x *NamedWhere) CreateStamp() *NamedWhere {
	x.buf.Write([]byte("{{BackQuote "create_stamp"}} = :create_stamp"))
	return x
}
{{end}}

func (x *NamedWhere) Limit(limit, offset int) *NamedWhere {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *NamedWhere) And() *NamedWhere {
	x.buf.Write([]byte(" and "))
	return x
}

func (x *NamedWhere) Or() *NamedWhere {
	x.buf.Write([]byte(" or "))
	return x
}

func (x *NamedWhere) Group(gf func(w *NamedWhere)) *NamedWhere {
	x.buf.WriteByte('(')
	gf(x)
	x.buf.WriteByte(')')
	return x
}

func (x *NamedWhere) Custom(f func(buf *util.Builder)) *NamedWhere {
	f(x.buf)
	return x
}

func (x *NamedWhere) OnDuplicateKeyUpdate() *NamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := false
	return &NamedUpdate{
		buf: x.buf,
		n:   &v,
		values: &values,
	}
}


func (x *NamedWhere) OnDuplicateKeyUpdateValues() *NamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := true
	return &NamedUpdate{
		buf: x.buf,
		n:   &v,
		values: &values,
	}
}

func (x *NamedWhere) ToSQL() string {
	return x.buf.String()
}

func (x *NamedWhere) OrderBy() *NamedOrderBy {
	x.buf.Write([]byte(" order by "))
	var v int
	return &NamedOrderBy{
		buf: x.buf,
		n:   &v,
	}
}

type NamedOrderBy struct {
	buf    *util.Builder
	n      *int
}

{{range $i,$col := $tbl.AllColumns false}}
func (x *NamedOrderBy) {{Title $col.Name}}() *NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{$col.SqlName}}"))
	*x.n++
	return &NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}
{{end}}
{{ if $tbl.GenEx }}
func (x *NamedOrderAsc) ModifyStamp() *NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "modify_stamp"}}"))
	*x.n++
	return &NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *NamedOrderAsc) CreateStamp() *NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("{{BackQuote "create_stamp"}}"))
	*x.n++
	return &NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}
{{end}}

func (x *NamedOrderBy) Limit(limit, offset int) *NamedOrderBy {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *NamedOrderBy) ToSQL() string {
	return x.buf.String()
}


type NamedOrderAsc struct {
	buf    *util.Builder
	n      *int
}

func (x *NamedOrderAsc) Asc() *NamedOrderBy {
	x.buf.Write([]byte(" asc "))
	return &NamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *NamedOrderAsc) Desc() *NamedOrderBy {
	x.buf.Write([]byte(" desc "))
	return &NamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *NamedOrderAsc) ToSQL() string {
	return x.buf.String()
}
