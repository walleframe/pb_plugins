// Code generated by {{.ToolName}} {{.Version}}. DO NOT EDIT.{{$tbl := .}}
package {{$tbl.DB}}

$Import-Packages$

////////////////////////////////////////////////////////////////////////////////
// public interface {{ $key := $tbl.PrimaryKey }} {{ $ksize := len $key }}{{ $defPkg := $tbl.DefPkg}}


type {{Title $tbl.Name}}Operation interface {
	Insert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error)
	InsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error)

{{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
	Update(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error){{end}}{{if $tbl.GenUpsert }}
	Upsert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error)
	UpsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error){{end}}
{{end}}

{{if $tbl.PrimaryKey}}
	Find(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindEx(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}Ex, err error){{end}}
	Delete(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (res sql.Result, err error)

	FindByKey(ctx context.Context, id {{$defPkg}}Key) (data *{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindExByKey(ctx context.Context, id {{$defPkg}}Key) (data *{{Title $tbl.Struct}}Ex, err error){{end}}
	DeleteByKey(ctx context.Context, id {{$defPkg}}Key) (res sql.Result, err error)

	FindByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindExByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (datas []*{{Title $tbl.Struct}}Ex, err error){{end}}
	DeleteByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (res sql.Result, err error)
{{end}}


{{- range $i,$idx := $tbl.Index }}{{if not $idx.IsUnique}}
	FindByIndex{{Title $idx.Name}}Frist(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}, err error)
	FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}limit,offset int) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindExByIndex{{Title $idx.Name}}Frist(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}Ex, err error)
	FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}limit,offset int) (datas []*{{Title $tbl.Struct}}Ex, err error){{end}}
	CountByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (count int, err error)
	DeleteByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (res sql.Result, err error)
{{else}}
	FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (datas *{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (datas *{{Title $tbl.Struct}}Ex, err error){{end}}
	DeleteByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (res sql.Result, err error){{end}}
{{end}}

	Select(ctx context.Context, findSql string, args ...any) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	SelectEx(ctx context.Context, findSql string, args ...any) (datas []*{{Title $tbl.Struct}}Ex, err error) {{end}}
	Count(ctx context.Context, findSql string, args ...any) (count int, err error)

	DeleteMany(ctx context.Context, findSql string, args ...any) (res sql.Result, err error)

	RangeAll(ctx context.Context, findSql string, oneQueryLimit int, f func(ctx context.Context, row *{{Title $tbl.Struct}}) bool,args ...any) error{{ if $tbl.GenEx }}
	RangeAllEx(ctx context.Context, findSql string, oneQueryLimit int, f func(ctx context.Context, row *{{Title $tbl.Struct}}Ex) bool,args ...any) error {{end}}
	AllData(ctx context.Context,findSql string, oneQueryLimit int, args ...any) (datas []*{{Title $tbl.Struct}}, err error){{ if $tbl.GenEx }}
	AllDataEx(ctx context.Context, findSql string, oneQueryLimit int,args ...any) (datas []*{{Title $tbl.Struct}}Ex, err error){{end}}

	// use for custom named sql
	DB() *sqlx.DB
}


var (
	global{{Title .Name}}OP atomic.Pointer[x{{Title $tbl.Name}}Operation]
)

func init() {
	{{$tbl.SvcDB}}.RegisterSyncDBTable("mysql", "{{$tbl.DB}}", "{{$tbl.SqlTable}}", Sync{{Title $tbl.Name}}DBTable)
	{{$tbl.SvcDB}}.RegisterDB("mysql", "{{$tbl.DB}}", "{{$tbl.SqlTable}}", func(db *sqlx.DB) error {
		//
		err := Sync{{Title $tbl.Name}}DBTable(context.Background(), db)
		if err != nil {
			return fmt.Errorf("swap {{$tbl.DB}}.{{$tbl.SqlTable}} pointer, %w", err)
		}
		//
		tableOP, err := New{{Title $tbl.Name}}Operation(db)
		if err != nil {
			return fmt.Errorf("swap {{$tbl.DB}}.{{$tbl.SqlTable}} pointer, new table operation failed, %w", err)
		}

		global{{Title $tbl.Name}}OP.Store(tableOP)
		return nil
	})
}

var {{Title $tbl.Name}}OP = func() {{Title $tbl.Name}}Operation {
	op := global{{Title .Name}}OP.Load()
	if op == nil {
		return nil
	}
	return op
}

func Sync{{Title $tbl.Name}}DBTable(ctx context.Context, db *sqlx.DB) (err error) {
	// sync table columns
	err = {{$tbl.SvcDB}}.SyncTableColumns(ctx, db, "{{$tbl.SqlTable}}", {{$defPkg}}SQL_Create, {{$defPkg}}SQL_TableColumns)
	if err != nil {
		return fmt.Errorf("sync {{$tbl.DB}}.{{$tbl.SqlTable}} table, sync columns failed, %w", err)
	}{{if $tbl.Index }}
	// sync table index
	err = {{$tbl.SvcDB}}.SyncTableIndex(ctx, db, "{{$tbl.SqlTable}}", {{$defPkg}}SQL_TableIndex)
	if err != nil {
		return fmt.Errorf("sync {{$tbl.DB}}.{{$tbl.SqlTable}} table, sync index failed, %w", err)
	}{{end}}
	return
}

func (tx *{{Title $tbl.DB}}Tx) {{Title $tbl.Name}}(){{Title $tbl.Name}}Operation {
	txOp := &x{{Title $tbl.Name}}Tx{tx:tx.tx}
	op := global{{Title .Name}}OP.Load()
	if op.db == tx.db {
		txOp.op = op
	}
	return txOp
}

////////////////////////////////////////////////////////////////////////////////
// Table Operation impl

type x{{Title $tbl.Name}}Operation struct {
	db      *sqlx.DB
	insert  *sql.Stmt{{ if $tbl.AutoIncr}}
	insert2 *sql.Stmt // increment id {{end}} {{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
	update  *sql.Stmt{{end}}{{if $tbl.GenUpsert }}
	upsert  *sql.Stmt{{end}}
	delete  *sql.Stmt
	find    *sql.Stmt {{ if $tbl.GenEx }}
	findRow *sql.Stmt {{end}} {{end}} {{- range $i,$idx := $tbl.Index }}
	idx{{Title $idx.Name}}Find *sql.Stmt{{ if $tbl.GenEx }}
	idx{{Title $idx.Name}}FindEx *sql.Stmt{{end}}
	idx{{Title $idx.Name}}Count *sql.Stmt
	idx{{Title $idx.Name}}Delete *sql.Stmt{{end}}
}

func New{{Title $tbl.Name}}Operation(db *sqlx.DB) (_ *x{{Title $tbl.Name}}Operation, err error) {
	t := &x{{Title $tbl.Name}}Operation{
		db: db,
	}

	t.insert, err = db.Prepare({{$defPkg}}SQL_Insert)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} insert failed,%w", err)
	}{{ if $tbl.AutoIncr}}
	t.insert2, err = db.Prepare({{$defPkg}}SQL_Insert2)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} insert2 failed,%w", err)
	}{{end}} {{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
	t.update, err = db.Prepare({{$defPkg}}SQL_Update)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} update failed,%w", err)
	}{{end}}{{if $tbl.GenUpsert }}
	t.upsert, err = db.Prepare({{$defPkg}}STMT_Upsert)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} upsert failed,%w", err)
	}{{end}}
	t.delete, err = db.Prepare({{$defPkg}}STMT_Delete)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} delete failed,%w", err)
	}
	t.find, err = db.Prepare({{$defPkg}}STMT_Find)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} find failed,%w", err)
	}{{ if $tbl.GenEx }}
	t.findRow, err = db.Prepare({{$defPkg}}STMT_FindRow)
	if err != nil {
		return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} findex failed,%w", err)
	}{{end}} {{end}}

	return t, nil
}

func (t *x{{Title $tbl.Name}}Operation) Insert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{ if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} != 0 {
		res, err = t.insert2.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	} else {
		res, err = t.insert.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}{{else}}
	res, err = t.insert.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}) {{end}}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert failed,%w", err)
	}

	return
}

func (t *x{{Title $tbl.Name}}Operation) InsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return t.Insert(ctx, datas[0])
	}
{{ if $tbl.AutoIncr}}
	// auto increment field
	withID := datas[0].{{Title $tbl.AutoIncr.Name}} != 0
	// 必须都设置了 incr id 或者都没有设置 incr.
	for i := 1; i < len(datas); i++ {
		if withID != (datas[i].{{Title $tbl.AutoIncr.Name}} != 0) {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} check failed, auto increment field not match. frist:%t %d:%t", withID, i, !withID)
		}
	}
	if withID {
		buf := util.Builder{}
		buf.Grow(len({{$defPkg}}SQL_Insert2) + (len(datas)-1)*len({{$defPkg}}SQL_InsertValues2))
		buf.Write([]byte({{$defPkg}}SQL_Insert2))
		for i := 0; i < len(datas)-1; i++ {
			buf.Write([]byte({{$defPkg}}SQL_InsertValues2))
		}
		args := make([]any, 0, len(datas)*{{$all := $tbl.AllColumns false}}{{len $all}})
		for i := 0; i < len(datas); i++ {
			data := datas[i]
			args = append(args, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
		}
		res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert_many withid failed,%w", err)
		}
		return
	}
{{end}}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Insert) + (len(datas)-1)*len({{$defPkg}}SQL_InsertValues))
	buf.Write([]byte({{$defPkg}}SQL_Insert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_InsertValues))
	}
	args := make([]any, 0, len(datas)*{{$all := $tbl.AllColumns true}}{{len $all}})
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert_many failed,%w", err)
	}
	return
}

{{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
func (t *x{{Title $tbl.Name}}Operation) Update(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{- if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} == 0 {
		return nil, errors.New("update {{$tbl.SqlTable}} not set primary key")
	}{{end}}
	res, err = t.update.ExecContext(ctx, {{range $i,$col := $tbl.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}data.{{Title $col.Name}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} update failed,%w", err)
	}

	return
}

{{end}}{{if $tbl.GenUpsert }}
func (t *x{{Title $tbl.Name}}Operation) Upsert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{ if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} == 0 {
		return t.Insert(ctx, data)
	}{{end}}

	res, err = t.upsert.ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert failed,%w", err)
	}

	return
}

func (t *x{{Title $tbl.Name}}Operation) UpsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return t.Upsert(ctx, datas[0])
	}
{{ if $tbl.AutoIncr}}
	// auto increment field
	for i := 1; i < len(datas); i++ {
		if datas[i].{{Title $tbl.AutoIncr.Name}} == 0 {
			return nil, errors.New("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert_many check not set incr id")
		}
	}{{end}}

	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Upsert) + (len(datas)-1)*len({{$defPkg}}SQL_InsertValues2) + len({{$defPkg}}SQL_UpsertUpdate))
	buf.Write([]byte({{$defPkg}}SQL_Upsert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_InsertValues2))
	}
	buf.Write([]byte({{$defPkg}}SQL_UpsertUpdate))
	args := make([]any, 0, len(datas)* {{$all := $tbl.AllColumns false}}{{len $all}})
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert_many failed,%w", err)
	}
	return
}
{{end}}
{{end}}

{{if $tbl.PrimaryKey}}
// find by primary key
func (t *x{{Title $tbl.Name}}Operation) Find(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}, err error) {
	rows, err := t.find.QueryContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return {{$defPkg}}Scan(rows)
	}
	return
}
{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindEx(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}Ex, err error) {
	rows, err := t.findRow.QueryContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return {{$defPkg}}ScanEx(rows)
	}
	return
}
{{end}}
func (t *x{{Title $tbl.Name}}Operation) Delete(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete failed,%w", err)
	}

	return
}

// find by primary key
func (t *x{{Title $tbl.Name}}Operation) FindByKey(ctx context.Context, id {{$defPkg}}Key) (data *{{Title $tbl.Struct}}, err error) {
	rows, err := t.find.QueryContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_key failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		return {{$defPkg}}Scan(rows)
	}
	return
}
{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindExByKey(ctx context.Context, id {{$defPkg}}Key) (data *{{Title $tbl.Struct}}Ex, err error) {
	rows, err := t.findRow.QueryContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_key failed,%w", err)
	}
	defer rows.Close()
	data = &{{Title $tbl.Struct}}Ex{}
	for rows.Next() {
		return {{$defPkg}}ScanEx(rows)
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) DeleteByKey(ctx context.Context, id {{$defPkg}}Key) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} del_by_key failed,%w", err)
	}

	return
}

// find by primary key
func (t *x{{Title $tbl.Name}}Operation) FindByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (datas []*{{Title $tbl.Struct}}, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*{{Title $tbl.Struct}}{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Find) + len({{$defPkg}}SQL_Where1)+ (len(ids)-1)*len({{$defPkg}}SQL_Where2))
	buf.Write([]byte({{$defPkg}}SQL_Find))
	buf.Write([]byte({{$defPkg}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_Where2))
	}

	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindExByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindExByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*{{Title $tbl.Struct}}Ex{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_FindRow) + len({{$defPkg}}SQL_Where1)+ (len(ids)-1)*len({{$defPkg}}SQL_Where2))
	buf.Write([]byte({{$defPkg}}SQL_FindRow))
	buf.Write([]byte({{$defPkg}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_Where2))
	}

	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) DeleteByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (res sql.Result, err error) {
	switch len(ids) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return t.DeleteByKey(ctx, ids[0])
	}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Delete) + len({{$defPkg}}SQL_Where1)+ (len(ids)-1)*len({{$defPkg}}SQL_Where2))
	buf.Write([]byte({{$defPkg}}SQL_Delete))
	buf.Write([]byte({{$defPkg}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_Where2))
	}

	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} del_by_key_array failed,%w", err)
	}
	return
}

{{end}}

{{- range $i,$idx := $tbl.Index }}{{if not $idx.IsUnique}}
func (t *x{{Title $tbl.Name}}Operation) FindByIndex{{Title $idx.Name}}Frist(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}, err error) {
	if t.idx{{Title $idx.Name}}Find == nil {
		t.idx{{Title $idx.Name}}Find, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindFrist)
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}Find.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		return data, nil
	}
	return
}

func (t *x{{Title $tbl.Name}}Operation) FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}} limit,offset int) (datas []*{{Title $tbl.Struct}}, err error) {
	if t.idx{{Title $idx.Name}}Find == nil {
		t.idx{{Title $idx.Name}}Find, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindMore)
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}Find.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindExByIndex{{Title $idx.Name}}Frist(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}Ex, err error) {
	if t.idx{{Title $idx.Name}}FindEx == nil {
		t.idx{{Title $idx.Name}}FindEx, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindRowFirst)
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}FindEx.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		return data,nil
	}
	return
}
func (t *x{{Title $tbl.Name}}Operation) FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}} limit,offset int) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	if t.idx{{Title $idx.Name}}FindEx == nil {
		t.idx{{Title $idx.Name}}FindEx, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindRowMore)
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}FindEx.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}{{end}}

func (t *x{{Title $tbl.Name}}Operation) CountByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (count int, err error) {
	if t.idx{{Title $idx.Name}}Count == nil {
		t.idx{{Title $idx.Name}}Count, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}Count)
		if err != nil {
			return 0, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} count_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	err = t.idx{{Title $idx.Name}}Count.QueryRowContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} count_by_index_{{$idx.Name}} failed,%w", err)
	}
	return
}
{{else}}

func (t *x{{Title $tbl.Name}}Operation) FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}, err error) {
	if t.idx{{Title $idx.Name}}Find == nil {
		t.idx{{Title $idx.Name}}Find, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}Find)
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}Find.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		return data,nil
	}
	return
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}Ex, err error) {
	if t.idx{{Title $idx.Name}}FindEx == nil {
		t.idx{{Title $idx.Name}}FindEx, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindRowMore)
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	rows, err := t.idx{{Title $idx.Name}}FindEx.QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		return data,nil
	}
	return
}{{end}}

{{end}}

func (t *x{{Title $tbl.Name}}Operation) DeleteByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (res sql.Result, err error) {
if t.idx{{Title $idx.Name}}Delete == nil {
		t.idx{{Title $idx.Name}}Delete, err = t.db.PrepareContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}Delete)
		if err != nil {
			return nil, fmt.Errorf("prepare {{$tbl.DB}}.{{$tbl.SqlTable}} delete_by_index_{{$idx.Name}} failed,%w", err)
		}
	}
	res, err = t.idx{{Title $idx.Name}}Delete.ExecContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete_by_index_{{$idx.Name}} failed,%w", err)
	}
	return
}

{{end}}


func (t *x{{Title $tbl.Name}}Operation) Select(ctx context.Context, findSql string, args ...any) (datas []*{{Title $tbl.Struct}}, err error) {
	rows, err := t.db.QueryContext(ctx, findSql, args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} select failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {

		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) SelectEx(ctx context.Context, findSql string, args ...any) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	rows, err := t.db.QueryContext(ctx, findSql, args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} selectex failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) Count(ctx context.Context, findSql string, args ...any) (count int, err error) {
	err = t.db.QueryRowContext(ctx, findSql, args...).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} count failed,%w", err)
	}
	return
}


func (t *x{{Title $tbl.Name}}Operation) DeleteMany(ctx context.Context, deleteSql string, args ...any) (res sql.Result, err error) {
	res, err = t.db.ExecContext(ctx, deleteSql, args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete_many failed,%w", err)
	}

	return
}

func (t *x{{Title $tbl.Name}}Operation) RangeAll(ctx context.Context, findSql string, limit int, f func(ctx context.Context, row *{{Title $tbl.Struct}}) bool, args ...any) error {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	count := 0
	for {
		buf := util.Builder{}
		buf.Reset()
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := {{$defPkg}}Scan(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) RangeAllEx(ctx context.Context, findSql string,limit int, f func(ctx context.Context, row *{{Title $tbl.Struct}}Ex) bool, args ...any) error {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := {{$defPkg}}ScanEx(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) AllData(ctx context.Context, findSql string, limit int, args ...any) (datas []*{{Title $tbl.Struct}}, err error) {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	datas = make([]*{{Title $tbl.Struct}}, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} all_data failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := {{$defPkg}}Scan(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

{{ if $tbl.GenEx }}
func (t *x{{Title $tbl.Name}}Operation) AllDataEx(ctx context.Context, findSql string, limit int, args ...any) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	datas = make([]*{{Title $tbl.Struct}}Ex, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} all_data_ex failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := {{$defPkg}}ScanEx(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}
{{end}}

func (t *x{{Title $tbl.Name}}Operation) DB() *sqlx.DB {
	return t.db
}


////////////////////////////////////////////////////////////////////////////////
// tx support
type x{{Title $tbl.Name}}Tx struct{
	tx *sqlx.Tx
	op *x{{Title $tbl.Name}}Operation
}


func (tx x{{Title $tbl.Name}}Tx) Insert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{ if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} != 0 {
		if tx.op != nil {
			res, err = tx.tx.StmtContext(ctx, tx.op.insert2).ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
		} else {
			res, err = tx.tx.ExecContext(ctx, {{$defPkg}}SQL_Insert2, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
		}
	} else {
		if tx.op != nil {
			res, err = tx.tx.StmtContext(ctx, tx.op.insert).ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
		} else {
			res, err = tx.tx.ExecContext(ctx, {{$defPkg}}SQL_Insert, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
		}
	}{{else}}
	if tx.op != nil {
		res, err = tx.tx.StmtContext(ctx, tx.op.insert).ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	} else {
		res, err = tx.tx.ExecContext(ctx, {{$defPkg}}SQL_Insert, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	} {{end}}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert failed,%w", err)
	}

	return
}

func (tx x{{Title $tbl.Name}}Tx) InsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return tx.Insert(ctx, datas[0])
	}
{{ if $tbl.AutoIncr}}
	// auto increment field
	withID := datas[0].{{Title $tbl.AutoIncr.Name}} != 0
	// 必须都设置了 incr id 或者都没有设置 incr.
	for i := 1; i < len(datas); i++ {
		if withID != (datas[i].{{Title $tbl.AutoIncr.Name}} != 0) {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} check failed, auto increment field not match. frist:%t %d:%t", withID, i, !withID)
		}
	}
	if withID {
		buf := util.Builder{}
		buf.Grow(len({{$defPkg}}SQL_Insert2) + (len(datas)-1)*len({{$defPkg}}SQL_InsertValues2))
		buf.Write([]byte({{$defPkg}}SQL_Insert2))
		for i := 0; i < len(datas)-1; i++ {
			buf.Write([]byte({{$defPkg}}SQL_InsertValues2))
		}
		args := make([]any, 0, len(datas)*{{$all := $tbl.AllColumns false}}{{len $all}})
		for i := 0; i < len(datas); i++ {
			data := datas[i]
			args = append(args, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
		}
		res, err = tx.tx.ExecContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert_many withid failed,%w", err)
		}
		return
	}
{{end}}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Insert) + (len(datas)-1)*len({{$defPkg}}SQL_InsertValues))
	buf.Write([]byte({{$defPkg}}SQL_Insert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_InsertValues))
	}
	args := make([]any, 0, len(datas)*{{$all := $tbl.AllColumns true}}{{len $all}})
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, {{range $i,$col := $tbl.AllColumns true}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	res, err = tx.tx.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} insert_many failed,%w", err)
	}
	return
}

{{if $tbl.PrimaryKey}}{{if $tbl.GenUpdate}}
func (tx x{{Title $tbl.Name}}Tx) Update(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{- if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} == 0 {
		return nil, errors.New("update {{$tbl.SqlTable}} not set primary key")
	}{{end}}
	if tx.op != nil {
		res, err = tx.tx.StmtContext(ctx, tx.op.update).ExecContext(ctx, {{range $i,$col := $tbl.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}data.{{Title $col.Name}}{{end}})
	}else {
		res, err = tx.tx.ExecContext(ctx, {{$defPkg}}SQL_Update, {{range $i,$col := $tbl.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}data.{{Title $col.Name}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} update failed,%w", err)
	}

	return
}

{{end}}{{if $tbl.GenUpsert }}
func (tx x{{Title $tbl.Name}}Tx) Upsert(ctx context.Context, data *{{Title $tbl.Struct}}) (res sql.Result, err error) { {{ if $tbl.AutoIncr}}
	// auto increment field
	if data.{{Title $tbl.AutoIncr.Name}} == 0 {
		return tx.Insert(ctx, data)
	}{{end}}

	if tx.op != nil {
		res, err = tx.tx.StmtContext(ctx, tx.op.upsert).ExecContext(ctx, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}else {
		res, err = tx.tx.ExecContext(ctx, {{$defPkg}}STMT_Upsert, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert failed,%w", err)
	}

	return
}

func (tx x{{Title $tbl.Name}}Tx) UpsertMany(ctx context.Context, datas []*{{Title $tbl.Struct}}) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return tx.Upsert(ctx, datas[0])
	}
{{ if $tbl.AutoIncr}}
	// auto increment field
	for i := 1; i < len(datas); i++ {
		if datas[i].{{Title $tbl.AutoIncr.Name}} == 0 {
			return nil, errors.New("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert_many check not set incr id")
		}
	}{{end}}

	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Upsert) + (len(datas)-1)*len({{$defPkg}}SQL_InsertValues2) + len({{$defPkg}}SQL_UpsertUpdate))
	buf.Write([]byte({{$defPkg}}SQL_Upsert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_InsertValues2))
	}
	buf.Write([]byte({{$defPkg}}SQL_UpsertUpdate))
	args := make([]any, 0, len(datas)* {{$all := $tbl.AllColumns false}}{{len $all}})
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, {{range $i,$col := $tbl.AllColumns false}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}data.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	res, err = tx.tx.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} upsert_many failed,%w", err)
	}
	return
}
{{end}}
{{end}}

{{if $tbl.PrimaryKey}}
// find by primary key
func (tx x{{Title $tbl.Name}}Tx) Find(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}, err error) {
	var rows *sql.Rows
	if tx.op != nil {
		rows,err = tx.tx.StmtContext(ctx, tx.op.find).QueryContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}else {
		rows,err = tx.tx.QueryContext(ctx,{{$defPkg}}STMT_Find,	{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return {{$defPkg}}Scan(rows)
	}
	return
}
{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) FindEx(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (data *{{Title $tbl.Struct}}Ex, err error) {
	var rows *sql.Rows
	if tx.op != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.findRow).QueryContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}else {
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_FindRow,{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return {{$defPkg}}ScanEx(rows)
	}
	return
}
{{end}}
func (tx x{{Title $tbl.Name}}Tx) Delete(ctx context.Context, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}} {{$col.GoType}}{{end}}) (res sql.Result, err error) {
	if tx.op != nil {
		res, err = tx.tx.StmtContext(ctx, tx.op.delete).ExecContext(ctx, {{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}}{{end}})
	}else {
		res, err = tx.tx.ExecContext(ctx, {{$defPkg}}STMT_Delete,{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{$col.Name}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete failed,%w", err)
	}

	return
}

// find by primary key
func (tx x{{Title $tbl.Name}}Tx) FindByKey(ctx context.Context, id {{$defPkg}}Key) (data *{{Title $tbl.Struct}}, err error) {
	var rows *sql.Rows
	if tx.op != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.find).QueryContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}else {
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_Find,{{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_key failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		return {{$defPkg}}Scan(rows)
	}
	return
}

{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) FindExByKey(ctx context.Context, id {{$defPkg}}Key) (data *{{Title $tbl.Struct}}Ex, err error) {
	var rows *sql.Rows
	if tx.op != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.findRow).QueryContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}else {
		rows, err = tx.tx.QueryContext(ctx,{{$defPkg}}STMT_FindRow, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_key failed,%w", err)
	}
	defer rows.Close()
	data = &{{Title $tbl.Struct}}Ex{}
	for rows.Next() {
		return {{$defPkg}}ScanEx(rows)
	}
	return
}
{{end}}

func (tx x{{Title $tbl.Name}}Tx) DeleteByKey(ctx context.Context, id {{$defPkg}}Key) (res sql.Result, err error) {
	if tx.op != nil {
		res, err = tx.tx.StmtContext(ctx, tx.op.delete).ExecContext(ctx, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}else {
		res, err = tx.tx.ExecContext(ctx,{{$defPkg}}STMT_Delete, {{if eq $ksize 1}}id{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}id.{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} del_by_key failed,%w", err)
	}

	return
}

// find by primary key
func (tx x{{Title $tbl.Name}}Tx) FindByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (datas []*{{Title $tbl.Struct}}, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := tx.FindByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*{{Title $tbl.Struct}}{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Find) + len({{$defPkg}}SQL_Where1)+ (len(ids)-1)*len({{$defPkg}}SQL_Where2))
	buf.Write([]byte({{$defPkg}}SQL_Find))
	buf.Write([]byte({{$defPkg}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_Where2))
	}

	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	rows, err := tx.tx.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) FindExByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := tx.FindExByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*{{Title $tbl.Struct}}Ex{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_FindRow) + len({{$defPkg}}SQL_Where1)+ (len(ids)-1)*len({{$defPkg}}SQL_Where2))
	buf.Write([]byte({{$defPkg}}SQL_FindRow))
	buf.Write([]byte({{$defPkg}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_Where2))
	}

	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	rows, err := tx.tx.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{end}}

func (tx x{{Title $tbl.Name}}Tx) DeleteByKeyArray(ctx context.Context, ids []{{$defPkg}}Key) (res sql.Result, err error) {
	switch len(ids) {
	case 0:
		return {{$tbl.SvcDB}}.EmptyResult{}, nil
	case 1:
		return tx.DeleteByKey(ctx, ids[0])
	}
	buf := util.Builder{}
	buf.Grow(len({{$defPkg}}SQL_Delete) + len({{$defPkg}}SQL_Where1)+ (len(ids)-1)*len({{$defPkg}}SQL_Where2))
	buf.Write([]byte({{$defPkg}}SQL_Delete))
	buf.Write([]byte({{$defPkg}}SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte({{$defPkg}}SQL_Where2))
	}

	args := make([]any, 0, len(ids)*{{len $tbl.PrimaryKey}})
	for i := 0; i < len(ids); i++ {
		args = append(args, {{if eq $ksize 1}}ids[i]{{else}}{{range $i,$col := $tbl.PrimaryKey}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}ids[i].{{Title $col.Name}}{{if $col.Marshal }}){{end}}{{end}}{{end}})
	}
	res, err = tx.tx.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} del_by_key_array failed,%w", err)
	}
	return
}

{{end}}

{{- range $i,$idx := $tbl.Index }}{{if not $idx.IsUnique}}
func (tx x{{Title $tbl.Name}}Tx) FindByIndex{{Title $idx.Name}}Frist(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}, err error) {
	var rows *sql.Rows
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}Find != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}Find).QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}else {
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindFrist, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		return data, nil
	}
	return
}

func (tx x{{Title $tbl.Name}}Tx) FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}} limit,offset int) (datas []*{{Title $tbl.Struct}}, err error) {
	var rows *sql.Rows
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}Find != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}Find).QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	}else{
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindMore, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) FindExByIndex{{Title $idx.Name}}Frist(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}Ex, err error) {
	var rows *sql.Rows
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}FindEx != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}FindEx).QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	} else {
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindRowFirst, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		return data,nil
	}
	return
}
func (tx x{{Title $tbl.Name}}Tx) FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}} limit,offset int) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	var rows *sql.Rows
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}FindEx != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}FindEx).QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	}else {
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindRowMore, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}{{end}}

func (tx x{{Title $tbl.Name}}Tx) CountByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (count int, err error) {
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}Count != nil {
		err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}Count).QueryRowContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}).Scan(&count)
	}else {
		err = tx.tx.QueryRowContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}Count, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}).Scan(&count)
	}
	if err != nil {
		return 0, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} count_by_index_{{$idx.Name}} failed,%w", err)
	}
	return
}
{{else}}

func (tx x{{Title $tbl.Name}}Tx) FindByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}, err error) {
	var rows *sql.Rows
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}Find != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}Find).QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}else {
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}Find, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} find_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		return data,nil
	}
	return
}

{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) FindExByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (data *{{Title $tbl.Struct}}Ex, err error) {
	var rows *sql.Rows
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}FindEx != nil {
		rows, err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}FindEx).QueryContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	}else {
		rows, err = tx.tx.QueryContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}FindRowMore, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}}, offset, limit)
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} findex_by_index_{{$idx.Name}} failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		return data,nil
	}
	return
}{{end}}

{{end}}

func (tx x{{Title $tbl.Name}}Tx) DeleteByIndex{{Title $idx.Name}}(ctx context.Context, {{range $i,$col := $idx.Columns}}{{$col.Name}} {{$col.GoType}},{{end}}) (res sql.Result, err error) {
	if tx.op != nil && tx.op.idx{{Title $idx.Name}}Delete != nil {
		res, err = tx.tx.StmtContext(ctx, tx.op.idx{{Title $idx.Name}}Delete).ExecContext(ctx, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}else {
		res, err = tx.tx.ExecContext(ctx, {{$defPkg}}STMT_{{Title $idx.Name}}Delete, {{range $i,$col := $idx.Columns}}{{Comma $i}}{{if $col.Marshal }}{{$defPkg}}{{Title $col.Name}}Marshal({{end}}{{$col.Name}}{{if $col.Marshal }}){{end}}{{end}})
	}
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete_by_index_{{$idx.Name}} failed,%w", err)
	}
	return
}

{{end}}


func (tx x{{Title $tbl.Name}}Tx) Select(ctx context.Context, findSql string, args ...any) (datas []*{{Title $tbl.Struct}}, err error) {
	rows, err := tx.tx.QueryContext(ctx, findSql, args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} select failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {

		data, err := {{$defPkg}}Scan(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) SelectEx(ctx context.Context, findSql string, args ...any) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	rows, err := tx.tx.QueryContext(ctx, findSql, args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} selectex failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := {{$defPkg}}ScanEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
{{end}}

func (tx x{{Title $tbl.Name}}Tx) Count(ctx context.Context, findSql string, args ...any) (count int, err error) {
	err = tx.tx.QueryRowContext(ctx, findSql, args...).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} count failed,%w", err)
	}
	return
}


func (tx x{{Title $tbl.Name}}Tx) DeleteMany(ctx context.Context, deleteSql string, args ...any) (res sql.Result, err error) {
	res, err = tx.tx.ExecContext(ctx, deleteSql, args...)
	if err != nil {
		return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} delete_many failed,%w", err)
	}

	return
}

func (tx x{{Title $tbl.Name}}Tx) RangeAll(ctx context.Context, findSql string, limit int, f func(ctx context.Context, row *{{Title $tbl.Struct}}) bool, args ...any) error {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	count := 0
	for {
		buf := util.Builder{}
		buf.Reset()
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := tx.tx.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := {{$defPkg}}Scan(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) RangeAllEx(ctx context.Context, findSql string,limit int, f func(ctx context.Context, row *{{Title $tbl.Struct}}Ex) bool, args ...any) error {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := tx.tx.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := {{$defPkg}}ScanEx(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}
{{end}}

func (tx x{{Title $tbl.Name}}Tx) AllData(ctx context.Context, findSql string, limit int, args ...any) (datas []*{{Title $tbl.Struct}}, err error) {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	datas = make([]*{{Title $tbl.Struct}}, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := tx.tx.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} all_data failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := {{$defPkg}}Scan(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

{{ if $tbl.GenEx }}
func (tx x{{Title $tbl.Name}}Tx) AllDataEx(ctx context.Context, findSql string, limit int, args ...any) (datas []*{{Title $tbl.Struct}}Ex, err error) {
	offset := 0
	if limit == 0 {
		limit = 512
	}
	datas = make([]*{{Title $tbl.Struct}}Ex, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32+len(findSql))
		buf.WriteString(findSql)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := tx.tx.QueryContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec {{$tbl.DB}}.{{$tbl.SqlTable}} all_data_ex failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := {{$defPkg}}ScanEx(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}
{{end}}

func (tx x{{Title $tbl.Name}}Tx) DB() *sqlx.DB {
	panic("tx not support get db")
	// return tx.tx.db
}
